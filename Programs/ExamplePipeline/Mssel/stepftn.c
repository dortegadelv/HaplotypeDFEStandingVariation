//  Converts an arbitrary frequency trajectory into an approximating step function.
// Takes as input a trajectory in the format generated by trajectories.c , and converts it to a step
//  function specified in a format appropriate for mssel.
//
//  The step function approximation depends on a series of boundary points stored in freqints.h .

#include "freqints.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

main(int argc, char **argv )
{
  double a, b,  *freq , *mytimes, p ,  t , *fudge , s, age ;
  int popsize, ntpoints, ntrajs, gen, maxtpoints, currentinterval,  i , countints, myint ;
  int  traj , numinterval , N0  ;
  char line[1001] ;
 

  a = 1.0 ;
  b = 0.0 ;

  if( argc > 1 ){
		if( argv[1][0] == '-' ) { 
			fprintf(stderr,"stepftn [ a b ] ,  (times are transformed to : a*t + b ) \n");
           exit(1);
		}
 		else { 
		     a = strtod( argv[1],NULL ) ;
			b = strtod( argv[2],NULL ) ;
		}
    }
    maxtpoints = 10000 ;
  freq = (double *)malloc( (unsigned)maxtpoints*sizeof(double) ) ;
  mytimes = (double *)malloc( (unsigned)maxtpoints*sizeof(double) ) ;
	numinterval = 0 ;
	while( bounds[numinterval] < 1.0 ) numinterval++;
	fudge = (double *)malloc( (unsigned)numinterval*sizeof(double) ) ;

 do {
     if( fgets( line, 1000, stdin) == NULL ) {
	     fprintf(stderr,"stepftn [ a b ] ,  (times are transformed to : a*t + b ) \n");
         exit(1);
	 }
	if( line[0] == '/' ) printf("%s",line);
  }while ( line[0] == '/' );
 

  sscanf(line," %d N0: %d",&ntrajs, &N0 );
  printf("%d N0: %d\n", ntrajs,N0);
  printf("1\n");  /* number of subpopulations */
  fgets( line, 1000, stdin);
  if( line[0] != '#' ) { fprintf(stderr," file format error.\n"); exit(0); }
 for( traj = 0; traj < ntrajs; traj++){
    currentinterval = -2 ;
    countints = 0 ;
    while( 1 ) {
        sscanf(line,"# s: %lf age: %lf", &s, &age);

       if( fgets( line, 1000, stdin) == NULL ){
	      break;
	    }
	    if( line[0] == '#' ) break; 
   
        sscanf(line,"%lf %lf",&t,  &p);
		
		for( i=0; i<numinterval; i++) fudge[i] = 0.0 ;
		if( currentinterval > 0)
			fudge[currentinterval] = -0.05*(bounds[currentinterval]-bounds[currentinterval-1]) ;
			
		 if(currentinterval < numinterval-1 )
		   	fudge[currentinterval+1] = 0.05*(bounds[currentinterval+1]- bounds[currentinterval]) ;
			
		
        i = 0 ;
        while( p > bounds[i] + fudge[i] ) i++;
        i--;
		
				
		
        if( i != currentinterval){
           if( p == 1.0 ) freq[countints] = 1.0 ;
		   else if ( p == 0.0 ) freq[countints] = 0.0 ;
           else freq[countints] = (bounds[i+1]+bounds[i])/2.0  ;
           mytimes[countints] = t ;
           currentinterval = i ;
           countints++;
	       if( countints > maxtpoints -2 ){
		       maxtpoints += 5000 ;
		       freq = (double *)realloc(freq,(unsigned)(maxtpoints*sizeof(double)) );
		       mytimes = (double *)realloc(mytimes,(unsigned)(maxtpoints*sizeof(double)) );	 
	       }
       }
    }
	
	
	if( mytimes[countints-1] != t ){
	   mytimes[countints] = t;
	   freq[countints]  =  p ;
	      countints++;
			  }
    printf("n:\t%d s: %lf age: %lf\n", countints-1, s, age);
     
 /*
	   printf("%lf\t%lf\n",0.0,p);
 
    for( i = countints-1 ; i >= 0 ; i--){
        printf("%lf\t%lf\n", b+a*(t-mytimes[i]),freq[i] );
    }
    printf("%lf\t0.0\n", b+a*(t-mytimes[i]+0.000001) );
	*/
	
/*	for( i=0; i< countints; i++) printf("%lf\t%lf\n", mytimes[i], freq[i] ) ;   */
	for( i= countints-1; i>0 ; i--) printf("%lf\t%lf\n", a*( mytimes[countints-1]-mytimes[i]) + b , freq[i-1] ) ; 
	
	}
 
}
 

